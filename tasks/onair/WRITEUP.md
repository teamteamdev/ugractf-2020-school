# В эфире: Write-up

В данном задании участникам предложен веб-сервис на строго типизированном языке программирования **TypeScript**. Вся суть приложения сводится к тому, что люди могут писать публичные и приватные заметки и отвечать на них.

Механизм авторизации работает предельно просто — логин и пароль сохраняются в cookie через двоеточие и проверяются при каждом входе. Это кажется довольно слабой защитой, однако, поскольку и в логине, и в пароле двоеточия запрещены, с этим ничего не поделать.

На самом деле, нетрудно заметить множество логических ошибок, допущенных разработчиками при написании приложения. Как правило, при возникновении какой-то ошибки (пользователь не авторизован или не имеет доступа к чему-либо) необходимо вернуть ошибку, после чего приостановить обработку запроса — выйти из функции, не вызывая `next()` — таким образом, следующие обработчики запущены не будут. Однако, данное приложение всеми возможными способами нарушает данное правило — например, в проверке входа:

```typescript
checkUser(req: Request, res: Response, next: NextFunction) {
    (() => {
        <...>

        if (!user) {
            return res.status(403).send(`No user. <a href="/${req.token}/logout">Logout</a>`);
        }

        req.user = user;
    })();
    next();
}
```

Кажется, что здесь всё хорошо. Но фактически, `(() => {...})()` — это объявление анонимной функции в TypeScript и её вызов: выражение в первых скобках задаёт функцию без аргументов, а скобки в конце вызывают эту функцию.

Оператор `return` выходит только из этой анонимной функции, но не из всей проверки пользователя, и `next()` выполняется. Тем не менее, эта проблема ни к чему не приводит — при добавлении поста сохраняется добавивший его пользователь (и проверка типов приводит к ошибке), а просмотреть мы ничего не сможем, поскольку ответ пользователю уже отправлен.

Поищем ещё аналогичных ошибок. Учитывая то, что ответ можно отправить лишь один раз, а следующие мы не увидим, будем пристальнее смотреть на места, где контент создаётся нами — так мы даже без HTTP-ответа сможем как-то получить результат выполнения запроса.

И действительно, функция создания поста работает немного странно: она, помимо непосредственного написания записи, поддерживает создание поста из шаблона. При этом поля исходной записи копируются, в случае отсутствия таковых в запросе:

```typescript
if (typeof req.body.from === 'string' && req.body.from) {
    const fromPost = req.db.get('posts').find({id: req.body.from}).value();

    if (!fromPost || fromPost.isPrivate && fromPost.userId !== req.user.id) {
        res.sendStatus(403);
    }

    postData.title = fromPost.title;
    postData.text = fromPost.text;
}
```

И тут то же самое — ошибка 403 отсылается, но обработчик продолжает свою работу, в результате чего пост добавляется.

Итоговый алгоритм работы таков: берём ID всех приватных постов, и пытаемся склонировать этот пост с заголовком, но без текста. Мы получим 403 в любом случае, но сами копии создадутся. Важно помнить, что форму заполнить не получится, и запрос нужно отправить вручную. В одном из таких постов находим флаг.

Флаг: **ugra_who_writes_so_bad_code_b0c212b93b**
